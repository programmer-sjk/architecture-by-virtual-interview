# 가상 면접 사례로 배우는 대규모 시스템 설계 기초

## 1장. 사용자 수에 따른 규모 확장성

### 어떤 데이터베이스를 사용할 것인가?
- 전통적인 RDBMS나 비 관계형 데이터베이스를 선택할 수 있다.
- 아래의 경우 비 관계형 데이터베이스가 바람직한 선택일 수 있다.
  - 아주 낮은 응답 지연시간이 요구됨
  - 다루는 데이터가 비정형이라 관계형 데이터가 아님
  - 아주 많은 양의 데이터를 저장할 필요가 있음

### 수직적 규모 확장 vs 수평적 규모 확장
- 더 좋은 하드웨어 (Cpu, RAM)를 사용하는 스케일 업 방식과 서버를 늘리는 스케일 아웃 방식이 있다.
- 서버로 들어오는 트래픽 양이 적을 때는 수직적 확장이 좋은 방법이며 단순하다는 장점이 있다.
- 하지만 자동복구(failover)나 다중화 방안은 제시되지 않는다. 서버에 장애가 발생하면 웹 사이트는 중단된다.
- 따라서 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장이 적절하다.
- 앞의 설계에서 사용자는 웹 서버에 바로 연결된다. 웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다.
또한 너무 많은 사용자가 접속할 겨우 응답속도가 느려지거나 서버 접속이 불가능 할 수 있다. 이때에는 로드 밸런서를 도입하는게 좋다.

### 로드 밸런서
- 로드 밸런서는 웹 서버들에게 트래픽을 적절히 분산하는 역할을 하며 사용자는 로드밸런서의 공개 IP주소로 접속한다.
- 로드 밸런서에 두 대의 서버가 연결되어 있다고 가정할 떄, 한 대의 서버가 죽어도 다른 서버가 동작하므로 가용성이 향상된다.
- 웹 서버로 유입되는 트래픽이 증가한다면 서버를 더 추가하면 된다. 로드밸런서가 자동적으로 트래픽을 분산할 것이다.

### 데이터베이스 다중화
- master <-> slave로 다중화 한다. 쓰기 작업은 master DB에만 수행하며 slave DB는 읽기 작업을 수행한다.
- 보통 읽기 작업이 쓰기 작어보다 많으므로 한 대의 master DB에 여러 slave DB를 두는게 일반적이다.
- 더 나은 성능: 쓰기 작업은 주 서버로 전달되는 반면 읽기 작업은 부 서버로 분산되기 때문에 성능이 좋아진다.
- 가용성: 자연재해나 DB 서버 중 하나가 장애가 나더라도 다중화 되어 있다면 계속 서비스 할 수 있게 된다.

#### 문제상황 
- Slave DB가 한 대 뿐인데 장애가 발생한다면 읽기 연산은 master DB로 전달될 것이다. 동시에 새로운 Slave DB가 구동되어 장애서버를
대체할 것이다. Slave DB가 여러대라면 읽기 연산은 분산될 것이며 새로운 DB가 장애 서버를 대체할 것이다.
- Master DB가 다운되면 한 대의 Slave DB만 있는 경우, 그 DB가 새로운 master DB가 되고 새로운 Slave DB가 추가될 것이다.

### 캐시
- 캐시는 자주 사용되는 데이터를 메모리에 두고 요청이 빨리 처리되도록 돕는 저장소이다.
- 캐쉬 사용시 주의할 점
  - 캐시는 어떤 상황에 바람직할까? -> 데이터 갱신은 자주 발생하지 않지만 빈번하게 참조가 발생한다면 고려해볼만 하다.
  - 어떤 데이터를 두어야 할까? -> 캐시 서버가 재 시작되면 캐시 내의 모든 데이터가 사라지므로 영속적으로 보관할 데이터는 DB에 두어야 한다.
  - 어떻게 만료되는가? -> 만료기간이 너무 짧다면 DB를 많이 읽게 될 것이고 너무 길다면 원본가 차이가 날 가능성이 높아진다.
  - 장애는 어떻게 대처할 것인가? -> 캐시 서버를 한대만 둘 경우 장애 지점이 될 수 있으므로 여러 지역에 캐시 서버를 분산해야 한다.
  - 캐시 메모리는 얼마나 잡을것인가? -> 캐시 메모리가 너무 작으면 데이터가 캐시에서 자주 밀려나버려 캐시의 성능이 떨어진다. 이를 막을 한 가지
  방법은 메모리를 과할당 하는 것이다. 이렇게 하면 캐시에 보관할 데이터가 갑자기 늘어났을 때 생길 문제를 방지할 수 있다.
  - 데이터 방출 정책은 무엇인가? -> 캐시가 꽉 찬 상태에서 추가로 데이터를 넣어야 하는 경우, 기존 데이터를 내보내야 한다. 이를 방출 정책이라
  하는데, 가장 널리 쓰이는 것은 LRU(마지막으로 사용된 시점이 오래된 데이터를 내보내는 정책)

### 컨텐츠 전송 네트워크(CDN)
- CDN은 정적 컨텐츠를 전송하는데 쓰이는 분산된 네트워크이다. 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.
- 사용자가 웹 사이트를 방문하면 그 사용자에게 가장 가까운 CDN 서버가 정적 컨텐츠를 전달하게 된다.
- 예를 들어 사용자 A가 image를 요청 시, CDN 서버는 그 이미지가 없으면 서버에게 요청해 이미지를 저장 후 사용자에게 전달하게 된다.
이후 사용자 B가 image 요청 시, CDN 서버가 만료되지 않은 이미지를 응답하게 된다.
- CDN 사용시 고려해야 할 사항
  - 비용: CDN 데이터 전송 양에 따라 요금을 내게 되므로 자주 사용하지 않은 컨텐츠는 CDN에서 뺴자
  - 적절한 만료기한: 만료 기한이 너무 길면 컨텐츠의 신선도가 떨어질 것이고, 너무 짧으면 원본 서버에 너무 자주 접속하게 된다.
  - 장애 대처: CDN 자체가 죽었을 때를 고려해야 한다. 가령 CDN이 일정 기간 응답하지 않으면 원본 서버로부터 직접 컨텐츠를 가져오도록 구성한다.

### 무상태(stateless) 웹 계층
- 로그인, 세션 정보는 웹 계층에서 제거한다. 만약 상태(세션) 정보를 웹 계층이 유지할 경우 사용자 A가 1번 서버에서 로그인했을 경우,
사용자 A는 계속 1번 서버와 통신해야 하는 문제가 있다.
- 세션 데이터를 웹 계층에서 분리하고 저장소에 보관한다. 이 저장소는 RDBMS, Rdis 캐시 시스템, NoSQL 일 수도 있다.

### 데이터 센터
- 서비스가 성장하고 전 세계 사용자들이 사용한다면 여러 데이터 센터를 지원해야 한다.
- 두 개의 데이터 센터(US-West, US-East)를 사용한다면 사용자가는 가장 가까운 데이터 센터로 안내되는데 이 절차를 지리적 라우팅(GeoDNS) 이라 부른다.
- 이 때 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 이동하게 된다.
- 이 사례와 같이 다중 데이터센터 아키텍처를 만들려면 몇 가지 기술 난제 해결이 필요하다.
  - 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내야 하는데 GeoDNS는 사용자가 가장 가까운 데이터 센터로 트래픽을 보낼수 있게 해준다.
  - 데이터 동기화: 데이터 센터마다 동기화 된 DB를 사용하기 위해 여러 데이터 센터에 걸쳐 다중화 해야 한다.

### 메시지 큐
- 메시지 큐는 메시지의 무손실(메시지 큐에 보관된 메시지는 소비자가 꺼낼때까지 안전하게 보관되는 특성)을 보장하는 비동기 통신을 지원한다.
- 발행자가 메시지를 메시지 큐에 발행(publish)하면 구독자가 메시지를 받아 그에 맞는 동작을 수행한다.
- 메시지 큐를 이용하면 서비스간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 애플리케이션을 만들기 좋다. 생산자는 소비자 서버가 다운되어도
메시지를 발행할 수 있고 소비자는 생산자 서버가 다운되어도 메시지를 수신받아 일을 처리할 수 있다.

### 데이터베이스의 규모확장
- 저장할 데이터가 많아지면 DB에 대한 부하도 증가한다. DB 규모를 확장하는 방법은 수직적, 수평적 규모 확장이 있다.
- 수직적 확장은 CPU, RAM, DISK를 증설하는 방법으로 몇 가지 약점이 있다. HW는 한계가 있으므로 무한대로 증설할 수 없고 SPOF 위험성, 비용이 많이든다.
- DB의 수평적 확장은 샤딩이라 부르는데, 파티션 키라고도 불리는 샤딩키를 어떻게 정하느냐가 중요하다.

### 백만사용자 그 이상
- 시스템 규모를 확장하는 것은 지속적이고 반복적인 과정으로 이번 장에서 공부한 것을 정리하면
- 웹 계층은 무상태로
- 로드 밸런서를 통해 트래픽 분산
- 모든 계층에 다중화 도입
- 가능한 많은 데이터를 캐시할 것
- 정적 컨텐츠는 CDN을 통해 서비스 할 것
- 여러 데이터 센터들을 지원할 것.

## 2장. 개략적인 규모 추정

### 모든 프로그래머가 알아야 하는 응답지연 값
- 컴퓨터에서 구현된 연산들의 응답지연 값을 기반으로 아래의 사실들을 도출
- 메모리는 빠르지만 디스크는 아직도 느리다.
- 디스크 탐색은 가능한 피하라
- 단순한 압축 알고리즘은 빠르다.
- 데이터를 인터넷으로 전송하기 전 가능하면 압축하라
- 데이터 센터는 여러 지역에 분산되어 있고 센터들 간에 데이터를 주고 받는데는 시간이 걸린다.

## 3장. 시스템 설계 면접 공략법

### 1단계. 문제 이해 및 설계 범위 확정
- 면접관이 질문을 던지면 요구사항과 가정들을 분명히 하자. 면접관은 내가 질문을 하거나 스스로 어떤 가정을 하길 바랄 것이다.

### 2 단계. 개략적인 설계안 제시 및 동의 구하기
- 개략적인 설계안을 제시하고 면접관의 동의를 얻는다.

### 3 단계. 상세 설계
### 4 단계. 마무리

## 4장. 처리율 제한 장치 설계
- 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다.

### 처리율 제한 장치는 어디에 둘 것인가?
- 클라이언트의 요청은 쉽게 위/변조가 가능해서 보통 서버측에 둔다.
- 처리율이 초당 2개로 제한된 상황에서 3번쨰 요청을 보내면 처리율 제한 미들웨어에서 막히고 HTTP 429(Too many request) 응답을 반환한다.
- 구현하기에 충분한 인력이 없다면 상용 API 게이트웨이를 쓰는 것도 바람직하다.

### 개략적인 아키텍쳐
- 얼마나 많은 요청이 접수되었는지 추적할 수 있는 카운터를 사용자별로 둔다.
- 이 카운터는 DB 보다 Redis 같은 캐시에 저장하는게 바람직하다.
- 동작원리
  - 클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.
  - 레디스의 카운터르 가져와서 한도 초과시 거부되고, 도달하지 않았다면 요청은 API 서버로 전달된다. 미들웨어는 카운터 값을 증가시킨 후 레디스에 저장
  
### 상세 설계
- 클라이언트가 요청을 보내면 먼저 처리율 제한 미들웨어에 도달한다.
- 미들웨어는 제한 규칙과 카운터를 캐시에서 가져온다. 가져온 값에 근거하여 처리율 제한에 걸리지 않으면 API 서버로 보낸다.
- 처리율 제한에 걸렸다면 429에러를 클라이언트에 보낸다. 이 요청은 그대로 버릴 수도 메시지 큐에 보관할 수도 있다.

## 6장. 키-값 저장소 설계
- 레디스처럼 키 값 데이터베이스라 불리는 비 관계형 데이터베이스다.

### 단일 키 값 저장소
- 가장 직관적인 방법은 키-값 전부를 메모리에 해시 테이블로 저장하는 것이다. 하지만 모든 데이터르 메모리 안에 두는 것은 불가능하단 약점도 있다.
- 이 문제를 해결하기 위한 개선책으로는 
  - 데이터 압축
  - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스ㅡㅋ에 저장
- 허나 이렇게 개선해도 한 대 서버로 부족한 때가 찾아온다. 많은 데이터를 저장하려면 분산 키-값 저장소를 만들어야 한다.

### 분산 키-값 저장소
- CAP 정리는 일관성(C), 가용성(A), 파티션 감내(P) 세가지 요구사항을 동시에 만족하는 분산시스템을 설계하는 것은 불가능하단 정리다.
- 데이터 일관성: 클라이언트는 어떤 노드에 접속했냐와 상관없이 같은 데이터를 봐야 한다.
- 가용성: 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받아야 한다.
- 파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 네트워크에 통신장애가 발생하더라도 시스템은 계속 동작한다는 것을 의미.

### 이상적 상태
- 이상적 환경이라면 네트워크가 파티션 되는 상황은 발생하지 않는다. A 노드에 저장된 데이터는자동적으로 B, C 노드에 저장된다. 데이터의 일관성과
가용성도 만족된다.

### 실 세계의 분산 시스템
- 분산 시스템은 파티션 문제를 피할 수 없다. 따라서 파티션 문제가 발생하면 가용성과 일관성 중 하나를 선택해야 한다.
- A 노드에 장애가 발생했을 때 일관성을 선택한다면 데이터 불일치 문제를 피하기 위해 B,C 녿에 쓰기 연산을 중단시켜야 한다.
- 은행권 시스템은 데이터 일관성을 양보하지 않는다. 
- 가용성을 택한다면 낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 한다. 

## 7장. 분산 시스템을 위한 유일 ID 생성기 설계

### UUID
- 유일성이 보장되는 ID를 만드는 방법
- 만드는 방법이 단순하며 각 서버가 자기가 쓸 ID를 만드는 구조이므로 규모 확장이 쉽다.

### 티켓 서버
- auto_increment 기능을 갖춘 DB, 즉 티켓 서버를 중앙 집중형으로 하나만 사용한다.
- 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들수 있고 구현하기 쉽다.
- 티켓서버가 SPOF(Single Point Of Failure)가 된다. 이 서버에 장애가 발생하면 모든 시스템이 영향을 받는다.

## 8장. URL 단축키 설계

### 개략적 설계안 제시
- 클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신한다.
- 이때 서버는 두 메소드를 제공한다.
- POST /api/v1/data/shorten -> long url을 받아 단축 URL을 반환
- GET /api/v1/shorturl -> HTTP 리다이렉션 목적지가 될 원래 URL
- 단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 301 응답의 Location 헤더에 넣어 반환한다.

### 상세 설계
- 단축 URL, 원본 URL을 DB에 저장한다.
- 해시함수는 원래 URL을 단축 URL로 변환하는데 쓰인다.
- 해시 함수 구현에 쓰일 기수로는 해시 후 충돌해소와 Base-62 변환법이다.
- 해시 후 충돌해소
  - 긴 URL을 줄이려면 원래 URL을 줄이는 해시함수가 필요하다. 대표적으로 SHA-1 해시 함수를 돌려 만들어진 값에서 처음 7개 글자만 이용한다.
  - 7글자니까 충돌할 확률이 높아지는데 충돌이 해소될때까지 사전에 정한 문자열을 해시값에 덧붙인다.
  - 이렇게 충돌은 해소할 수 있지만 한 번이상 DB에 조회해야 하므로 오버헤드가 크다.
- BASE 62 변환
  - 62진법을 쓰는 이유는 Hash value에 사용할 수 있는 문자 개수(0-9, a-z, A-Z) 개수가 62개이기 때문이다.
  - 10진수 11157은 62진법으로 표현 시 2 * 62^2 + 55 * 62^1 + 59 + 62^0, 즉 2TX가 된다.

## 10장. 알림 시스템 설계
- 알림 시스템은 크게 모바일 푸시 알림, SMS 메시지, 이메일 세 가지로 분류된다.
- 이 중 SMS, 이메일은 상용 서비스를 많이 활용한다.

### 연락처 정보 수집 절차
- 알림을 보내려면 전화번호, 이메일 주소의 정보가 필요한데, 처음 계정 등록시 API 서버는 사용자의 정보를 DB에 저장한다.

### 설계 초안
- 1부터 N까지의 서비스: 마이크로 서비스 or 분산 시스템으로 설계할 알림 시스템에 요청한다. 
- 알림 시스템: 우선은 1개 서버로 가정하낟. 서비스 1~N에 알림 전송을 위한 API를 제공하고 3자 서비스에 전달할 요청을 생성한다.
- 제 3자 서비스: 메일 침프, 넥스모 같이 실제 사용자에게 알림을 전달하는 상용 서비스

#### 첫 번째 설계 문제
- SPOF: 알림 서비스에 서버가 하나밖에 없다는 것은 서버에 장애 발생시, 전체 서비스의 장애로 이어진다.
- 규모 확장성: 한 대 서비스로 모든 것을 처리하므로 DB나 캐시 등을 늘릴 방법이 없다.

### 개선된 설계

#### 설계 방향
- 데이터베이스와 캐시를 주 서버에서 분리한다.
- 알림 서버를 증설하고 자동으로 수평적 규모 확장이 가능하도록 한다.
- 메시지 큐를 이용해 시스템 간 강한 결합을 끊는다.

#### 설계
- 1부터 N까지의 서비스: 마이크로 서비스 or 분산 시스템으로 설계할 알림 시스템에 요청한다.
- 알림 시스템 (아래 기능 제공)
  - 알림 전송 API: 사내 서비스 or 인증된 사용자만 사용 가능
  - 알림 검증: 이메일 주소, 전화번호에 대한 검증 수행
  - DB or 캐시: 알림에 포함시킬 데이터 조회
  - 알림 전송: 알림 데이터를 메시지 큐에 넣는다.
- 캐시: 사용자 정보, 단말 정보, 템플릿 캐시
- DB: 사용자, 알림 설정 등의 정보 저장
- 메시지 큐: 알림의 종류별로 메시지 큐를 사용하여 3자 서비시 중 하나에 장애가 발생해도 다른 알림은 정상동작 해야한다.
- 작업 서버: 메시지 큐에서 알림을 꺼내 제 3자 서비스로 전달하는 역할
- 제 3자 서비스: 이미 설명함

#### 전송 순서
- API를 호출해 알림서버로 알림 전달. 알림 서버는 DB나 캐시를 통해 필요한 정보를 셋팅
- 알림 서버는 이벤트르 만들어 메시지 큐에 넣고 작업서바가 알림 이벤트를 꺼내 3자 서비스로 전송한다.
